"""
Script to process and visualize hit data from total_hits_data.json

This script:
1. Loads hit data from JSON file generated by Occupancy.py
2. Converts it to a 2D numpy array for analysis
3. Provides basic statistical analysis
4. Supports detector group analysis

load_hits_data() returns the data in the correct order for the plot.py script to use for further analysis. Use it to fit a 2D/3D histogram/distribution for analysis. 

Requirements:
- Python 3.x
- numpy
- matplotlib
- pandas
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from pathlib import Path
import json
from matplotlib.colors import Normalize
from matplotlib.patches import Rectangle

DETECTOR_GROUPS = [
    {'label': 'Station 1', 'detectors': [
        {'name': 'D0V', 'elements': 201, 'id': 5},
        {'name': 'D0Vp', 'elements': 201, 'id': 6},
        {'name': 'D0Xp', 'elements': 160, 'id': 4},
        {'name': 'D0X', 'elements': 160, 'id': 3},
        {'name': 'D0U', 'elements': 201, 'id': 1},
        {'name': 'D0Up', 'elements': 201, 'id': 2}
    ]},
    {'label': 'Hodo', 'detectors': [
        {'name': 'H1L', 'elements': 20, 'id': 33},
        {'name': 'H1R', 'elements': 20, 'id': 34},
        {'name': 'H1B', 'elements': 23, 'id': 31},
        {'name': 'H1T', 'elements': 23, 'id': 32}
    ]},
    {'label': 'DP-1', 'detectors': [
        {'name': 'DP1TL', 'elements': 80, 'id': 55},
        {'name': 'DP1TR', 'elements': 80, 'id': 56},
        {'name': 'DP1BL', 'elements': 80, 'id': 57},
        {'name': 'DP1BR', 'elements': 80, 'id': 58}
    ]},
    {'label': 'Station 2', 'detectors': [
        {'name': 'D2V', 'elements': 128, 'id': 13},
        {'name': 'D2Vp', 'elements': 128, 'id': 14},
        {'name': 'D2Xp', 'elements': 112, 'id': 15},
        {'name': 'D2X', 'elements': 112, 'id': 16},
        {'name': 'D2U', 'elements': 128, 'id': 17},
        {'name': 'D2Up', 'elements': 128, 'id': 18}
    ]},
    {'label': 'Hodo', 'detectors': [
        {'name': 'H2R', 'elements': 19, 'id': 36},
        {'name': 'H2L', 'elements': 19, 'id': 35},
        {'name': 'H2T', 'elements': 16, 'id': 38},
        {'name': 'H2B', 'elements': 16, 'id': 37}
    ]},
    {'label': 'DP-2', 'detectors': [
        {'name': 'DP2TL', 'elements': 48, 'id': 59},
        {'name': 'DP2TR', 'elements': 48, 'id': 60},
        {'name': 'DP2BL', 'elements': 48, 'id': 61},
        {'name': 'DP2BR', 'elements': 48, 'id': 62}
    ]},
    {'label': 'Station 3+', 'detectors': [
        {'name': 'D3pVp', 'elements': 134, 'id': 19},
        {'name': 'D3pV', 'elements': 134, 'id': 20},
        {'name': 'D3pXp', 'elements': 116, 'id': 21},
        {'name': 'D3pX', 'elements': 116, 'id': 22},
        {'name': 'D3pUp', 'elements': 134, 'id': 23},
        {'name': 'D3pU', 'elements': 134, 'id': 24}
    ]},
    {'label': 'Station 3-', 'detectors': [
        {'name': 'D3mVp', 'elements': 134, 'id': 25},
        {'name': 'D3mV', 'elements': 134, 'id': 26},
        {'name': 'D3mXp', 'elements': 116, 'id': 27},
        {'name': 'D3mX', 'elements': 116, 'id': 28},
        {'name': 'D3mUp', 'elements': 134, 'id': 29},
        {'name': 'D3mU', 'elements': 134, 'id': 30}
    ]},
    {'label': 'Hodo', 'detectors': [
        {'name': 'H3T', 'elements': 16, 'id': 40},
        {'name': 'H3B', 'elements': 16, 'id': 39}
    ]},
    {'label': 'Prop', 'detectors': [
        {'name': 'P1Y1', 'elements': 72, 'id': 47},
        {'name': 'P1Y2', 'elements': 72, 'id': 48}
    ]},
    {'label': 'Hodo', 'detectors': [
        {'name': 'H4Y1R', 'elements': 16, 'id': 42},
        {'name': 'H4Y1L', 'elements': 16, 'id': 41}
    ]},
    {'label': 'Prop', 'detectors': [
        {'name': 'P1X1', 'elements': 72, 'id': 49},
        {'name': 'P1X2', 'elements': 72, 'id': 50}
    ]},
    {'label': 'Hodo', 'detectors': [
        {'name': 'H4Y2R', 'elements': 16, 'id': 44},
        {'name': 'H4Y2L', 'elements': 16, 'id': 43},
        {'name': 'H4T', 'elements': 16, 'id': 46},
        {'name': 'H4B', 'elements': 16, 'id': 45}
    ]},
    {'label': 'Prop', 'detectors': [
        {'name': 'P2X1', 'elements': 72, 'id': 51},
        {'name': 'P2X2', 'elements': 72, 'id': 52},
        {'name': 'P2Y1', 'elements': 72, 'id': 53},
        {'name': 'P2Y2', 'elements': 72, 'id': 54}
    ]}
]

def get_detector_order():
    """Get the correct detector order based on detector groups."""
    detector_order = []
    for group in DETECTOR_GROUPS:
        for det in group['detectors']:
            detector_order.append(det['id'])
    return detector_order

def reorder_data(data):
    """
    Reorder the data array based on detector groups.
    
    Parameters:
    -----------
    data : numpy.ndarray
        2D array containing hit data
        
    Returns:
    --------
    reordered_data : numpy.ndarray
        Reordered 2D array
    """
    detector_order = get_detector_order()
    # Create a mapping from old detector ID to new position
    id_to_pos = {det_id: pos for pos, det_id in enumerate(detector_order)}
    
    # Create new array with correct ordering
    reordered_data = np.zeros_like(data)
    for old_pos, det_id in enumerate(range(data.shape[1])):
        if det_id in id_to_pos:
            new_pos = id_to_pos[det_id]
            reordered_data[:, new_pos] = data[:, old_pos]
    
    return reordered_data

def load_hits_data(file_path):
    """
    Load hit data from JSON file and convert to 2D numpy array
    
    Parameters:
    -----------
    file_path : str
        Path to the JSON file containing hit data
        
    Returns:
    --------
    hits_array : numpy.ndarray
        2D array containing hit data, oriented to match Occupancy.py's plotting style
    """
    # Read the JSON file
    with open(file_path, 'r') as f:
        data = json.load(f)
    
    # Convert the list back to numpy array
    hits_array = np.array(data['hits_array'], dtype=int)
    
    # Transpose the array to match Occupancy.py's plotting style
    hits_array = hits_array.T
    
    # Reorder the data based on detector groups
    hits_array = reorder_data(hits_array)
    
    return hits_array

def load_detector_summary(file_path):
    """
    Load detector summary data from CSV file
    
    Parameters:
    -----------
    file_path : str
        Path to the detector summary CSV file
        
    Returns:
    --------
    summary : dict
        Dictionary containing detector summary information
    """
    return pd.read_csv(file_path)

def plot_heatmap(data, title="Hit Distribution", save_path=None):
    """
    Create and display a heatmap of the hit data
    
    Parameters:
    -----------
    data : numpy.ndarray
        2D array containing hit data (already transposed and reordered)
    title : str
        Title for the plot
    save_path : str, optional
        Path to save the plot image
    """
    plt.figure(figsize=(12, 8))
    
    # Create heatmap - data is already transposed and reordered
    plt.imshow(data, cmap='viridis', aspect='auto', 
              extent=[0, data.shape[1]-1, 0, data.shape[0]-1])
    plt.colorbar(label='Number of Hits')
    
    # Add labels and title
    plt.xlabel('Detector ID')
    plt.ylabel('Element ID')
    plt.title(title)
    
    # Set correct axis limits
    plt.xlim(0, len(get_detector_order())-1)  # Use actual number of detectors
    plt.ylim(0, 201)  # Element ID range
    
    # Invert y-axis to match expected orientation
    plt.gca().invert_yaxis()
    
    # Add grid
    plt.grid(True, linestyle='--', alpha=0.3)
    plt.tight_layout()
    
    # Save plot if path is provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    
    plt.show()

def plot_boxes(data, title="Hit Distribution", save_path=None):
    """
    Create and display a box plot of the hit data, matching Occupancy.py's style
    
    Parameters:
    -----------
    data : numpy.ndarray
        2D array containing hit data (already transposed and reordered)
    title : str
        Title for the plot
    save_path : str, optional
        Path to save the plot image
    """
    fig, ax = plt.subplots(figsize=(16, 10))
    
    # Calculate normalization
    max_hits = np.max(data)
    norm = Normalize(vmin=0, vmax=max_hits)
    
    # Create box data
    box_data = []
    for det_id in range(data.shape[1]):
        for elem_id in range(data.shape[0]):
            count = data[elem_id, det_id]
            if count > 0:
                box_data.append((det_id, elem_id, count))
    
    # Plot boxes
    for x, y, count in box_data:
        # Calculate color based on hit count
        color_intensity = norm(count)
        color = plt.cm.Reds(color_intensity)
        
        # Draw rectangle with no edge
        rect = Rectangle((x - 0.5, y - 0.5), 1, 1, 
                        facecolor=color, 
                        edgecolor='none',
                        alpha=0.9)
        ax.add_patch(rect)
    
    # Customize plot
    ax.set_title(title, fontsize=16, pad=15)
    ax.set_xlabel("Detector ID", fontsize=14)
    ax.set_ylabel("Element ID", fontsize=14)
    ax.set_xlim(-0.5, len(get_detector_order())-0.5)  # Use actual number of detectors
    ax.set_ylim(0, data.shape[0])
    
    # Add colorbar
    sm = plt.cm.ScalarMappable(cmap='Reds', norm=norm)
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax, pad=0.02)
    cbar.set_label("Hit Count", rotation=90, labelpad=15, fontsize=14)
    
    plt.tight_layout()
    
    # Save plot if path is provided
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    
    plt.show()

def basic_statistics(data, summary_df=None):
    """
    Calculate and print basic statistics for the hit data
    
    Parameters:
    -----------
    data : numpy.ndarray
        2D array containing hit data
    summary_df : pd.DataFrame, optional
        DataFrame containing detector summary information
    """
    print("\nBasic Statistics:")
    print(f"Total number of hits: {np.sum(data)}")
    print(f"Mean hits per detector: {np.mean(data):.2f}")
    print(f"Standard deviation: {np.std(data):.2f}")
    print(f"Maximum hits: {np.max(data)}")
    print(f"Minimum hits: {np.min(data)}")
    
    # Calculate percentage of non-zero elements
    non_zero = np.count_nonzero(data)
    total_elements = data.size
    print(f"Percentage of active detectors: {(non_zero/total_elements)*100:.2f}%")
    
    # Print group statistics if summary is provided
    if summary_df is not None:
        print("\nGroup Statistics:")
        for group in summary_df['Group'].unique():
            group_detectors = summary_df[summary_df['Group'] == group]
            total_hits = group_detectors['Total_Hits'].sum()
            print(f"\n{group}:")
            print(f"Total hits: {total_hits}")
            print(f"Number of detectors: {len(group_detectors)}")
            print(f"Average hits per detector: {total_hits/len(group_detectors):.2f}")

def main():
    # File paths
    data_dir = Path("QTracker_Station_Occupancies")
    output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)
    
    # Load data
    print("Loading hit data...")
    hits_data = load_hits_data(data_dir / "total_hits_data.json")
    
    # Load detector summary
    summary_df = load_detector_summary(data_dir / "detector_summary.csv")
    
    # Basic statistics
    basic_statistics(hits_data, summary_df)
    
    # Create and save heatmap
    print("\nCreating heatmap visualization...")
    plot_heatmap(hits_data, 
                title="Detector Hit Distribution",
                save_path=output_dir / "hit_distribution.png")
    
    # Create and save box plot
    print("\nCreating box plot visualization...")
    plot_boxes(hits_data,
              title="Detector Hit Distribution (Box Plot)",
              save_path=output_dir / "hit_distribution_boxes.png")
    
    # Save processed data as numpy array
    np.save(output_dir / "processed_hits_data.npy", hits_data)
    print(f"\nProcessed data saved to: {output_dir / 'processed_hits_data.npy'}")
    
    # Example of how to load the saved data
    print("\nTo load the processed data in another script, you can use either:")
    print("\n1. Load from numpy file:")
    print("import numpy as np")
    print("data = np.load('output/processed_hits_data.npy')")
    
    print("\n2. Load from JSON file:")
    print("import json")
    print("with open('QTracker_Station_Occupancies/total_hits_data.json', 'r') as f:")
    print("    data = json.load(f)")
    print("hits_array = np.array(data['hits_array']).T")

if __name__ == "__main__":
    main() 